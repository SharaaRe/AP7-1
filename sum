#ifndef BUY_CONTROLLER_H
#define BUY_CONTROLLER_H

#include "Controller.h"

class BuyController : public Controller
{
public:
    virtual Response post(Request* request);
private:
    int film_id;
    void check_post_params();
    int calculate_publisher_debt(int price, float rate);

};


#endif#ifndef CLIENT_H
#define CLIENT_H


#include <string>
#include <vector>
#include <map>

#include "User.h"



class Film;
class Publisher;
class Comment;

typedef std::string Notification;

class Client :public User
{
public:
    Client(std::string email, std::string username, std::string password, int age);

    void follow(Publisher* follwing);
    void increase_credit(int amount);
    void purchase_film(Film* film);
    void send_notif(Notification new_notif);

    bool is_purchased(int film_id) const;
    virtual int get_type() const;
    std::string get_email() const;
    std::vector <Notification> get_notification();
    std::vector <Notification> get_read_notification();
    std::vector <int> get_purchased();

protected:
    static int last_id_created;
    std::string email;
    int age;
    int credit;
    std::map <int, Film*> purchased;
    std::map <int, const Publisher*> followings;
    std::vector <Notification> notifications;
    std::vector <Notification> read_notification;


};


#endif#ifndef COMMENTS_H
#define COMMENTS_H

#include <string>
#include <vector>

class Comment 
{
public:
    Comment() = default;
    Comment(int id, int writer_id, std::string content);
    void add_reply(std::string reply);
    int get_id() const;
    int get_writer_id();
    std::string get_content() const;
    std::vector <std::string> get_reply() const;
private:
    int id;
    int writer_id;
    std::string content;
    std::vector <std::string> reply;
};

#endif#ifndef COMMENTS_CONTROLLER_H
#define COMMENTS_CONTROLLER_H

#include <string>

#include "Controller.h"

class CommentsController: public Controller
{
public:
    virtual Response post(Request* request);
    virtual Response delete_(Request* request);
private:
    int film_id;
    int comment_id;
    std::string content;
    void check_post_params();
    void check_delete_params();
};

#endif#ifndef CONTROLLER_H
#define CONTROLLER_H

#include "Request.h"
#include "Response.h"

class Response;

class Controller 
{
    public:
        Controller();
        virtual Response put(Request* request);
        virtual Response get(Request* request);
        virtual Response post(Request* request);
        virtual Response delete_(Request* request);
    protected:
        Request* current_request;
        

};

#endif#ifndef CONTROLLER_MANAGER_H
#define CONTROLLER_MANAGER_H

#include <map>
#include <string>

#include "Controller.h"
#include "Request.h"
#include "Response.h"

class ControllerManager 
{
public:
    ControllerManager();
    ~ControllerManager();
    void run_controller(Request* request);
    Response get_response();
private:
    std::map <std::string, Controller*> controllers;
    Response response;

};


#endif#ifndef DATABASE_H
#define DATABASE_H

#include <map>
#include <vector>
#include <string>

class Film;
class Client;
class Publisher;
class User;

class DataBase 
{
public:
    static DataBase* get_instance();
    void add_client(Client* new_client);
    void add_film(Film* new_film);

    Client* search_client(int id);
    Client* search_client(std::string username);
    Film* search_film(int id);

    std::vector <Film> get_all_films();

    bool film_exist(int id);
    bool publisher_exist(int id);
    bool client_exist(int id);
    bool valid_username(std::string username);

    ~DataBase();
private:
    static DataBase* instance;
    std::map <int, Film*> films;
    std::map <int, Client*> clients;
    std::map <std::string, User*> admins;
    std::map <std::string, int> id;

};

#endif#include <exception>

#include <string>

// typedef std::exception Exception;

class Exception :public std::exception
{
public:
    Exception(std::string description);
    Exception();
    virtual const std::string error() const throw() = 0;
protected:
    std::string description;
};


class NotFound :public Exception
{
public:
    NotFound(std::string detail) : Exception(detail) {}
    virtual const std::string error() const throw();
    virtual const char* what() const throw();
};

class BadRequest :public Exception
{
public:
    BadRequest(std::string detail) : Exception(detail) {}
    virtual const std::string error() const throw();
    virtual const char* what() const throw();   
};

class PermissionDenied :public Exception
{
public:
    PermissionDenied(std::string detail) : Exception(detail) {}
    virtual const std::string error() const throw();
    virtual const char* what() const throw();    
};#ifndef FILM_CONTROLLER_H
#define FILM_CONTROLLER_H

#include <string>

#include "Controller.h"
#include "FilmService.h"
#include "Film.h"

class FilmController :public Controller
{
    public:
        FilmController();
        virtual Response get(Request* request);
        virtual Response post(Request* request);
        virtual Response put(Request* request);
        virtual Response delete_(Request* request);
    private:
        int id;
        FilmService film_service;
        std::string name;
        int year;
        int length;
        int price;
        std::string summary;
        std::string director;
        bool get_id_param_exist();
        void post_required_params();
        void put_params();
        void re_initialize();
        void set_id_param();
        std::string make_film_info_string(Film film);
        std::string make_recommendation_string(Film film);
        std::string make_comments_string(Film film);
};

#endif
#ifndef FILM_FILTER_CONTROLLER_H
#define FILM_FILTER_CONTROLLER_H

#include "Controller.h"
#include "FilmService.h"
#include "FilmFilterService.h"

class FilmFilterController: public Controller
{
public:
    virtual Response get(Request* request);
protected:
    Response make_get_film_respnse();
    std::vector <Film> films;
    FilmService film_service;
    std::string name;
    std::string director;
    int min_year;
    int max_year;
    int price;
    float rate;
    void default_filter();
    virtual void check_params();
    void re_initialize_params();
};


#endif#ifndef FILM_FILTER_SERVICE_H
#define FILM_FILTER_SERVICE_H

#include <vector> 
#include <map>
#include <string>

#include "Film.h"

#define NOT_FILTERED_ST "not filterd"
#define NOT_FILTERED -1

class FilmFilterService
{
public:
    FilmFilterService(std::vector <Film> films);
    FilmFilterService() = default;
    std::vector <Film> filter(std::string name = NOT_FILTERED_ST, int max_year = NOT_FILTERED, int min_year = NOT_FILTERED,
             int price = NOT_FILTERED, float min_rate = NOT_FILTERED, std::string director = NOT_FILTERED_ST);
    void stable_sort_by_rate();
    void filter_purchased(std::vector <Film> purchased);
    void filter_not_available();
    std::vector <Film> get_filtered();
protected:
    std::vector <Film> films;
    void filter_by_name(std::string name);
    void filter_by_max_year(int max_year);
    void filter_by_min_year(int min_year);
    void filter_by_price(int price);
    void filter_by_min_rate(float rate);
    void filter_by_director(std::string director);
    static bool compare_by_rate(Film first, Film second);
};

#endif#ifndef FILMS_H
#define FILMS_H

#include <string>
#include <vector>
#include <map>

#define NOT_CHANGED "not changed"
#define VALUE_NOT_CHANGED  -1

#include "Comment.h"

class Film
{
public:
    Film(std::string name, int year, int length, int price, std::string summary, std::string director, int publisher_id);
    void delete_();
    bool is_available();
    void add_comment(std::string comment_content, int writer_id);
    void reply_comment(int comment_id, std::string reply_content);
    void delete_comment(int comment_id);
    void add_score(int score);


    void set_name(std::string name);
    std::string get_name();
    void set_year(int year);
    int get_year();
    void set_length(int length);
    int get_length();
    void set_summary(std::string summary);
    std::string get_summary();
    void set_director(std::string director);
    std::string get_director();
    int get_price();
    int get_id();
    float get_rate();
    int get_publisher_id();
    int get_commenter_id(int comment_id);
    std::vector <Comment> get_comments();


private:
    static int last_id_created;
    int id;
    std::string name;
    int year;
    int length; //minutes
    int price;
    std::string summary;
    std::string director;
    bool available;

    int publisher_id;

    std::map <int, Comment> comments;
    int last_comment_id;
    std::vector <int> scores;

    float rate;
};

#endif#ifndef FILM_SERVICE_H
#define FILM_SERVICE_H

#include <string>
#include <vector>

#include "Client.h"
#include "Publisher.h"
#include "Film.h"

#define NAME "name"
#define FILM_ID "film_id"
#define COMMENT_ID "comment_id"
#define CONTENT "content"
#define SCORE "score"
#define NOT_CHANGED "not changed"
#define VALUE_NOT_CHANGED -1

class DataBase;
class UserSessionManagement;

typedef std::string Notification;

class FilmService
{
public:
    FilmService();
    void buy(int film_id);
    void add_film(std::string name, int year, int length, int price, std::string summary, std::string director);
    void edit_film(int id, std::string name = NOT_CHANGED, int year = VALUE_NOT_CHANGED,int length = VALUE_NOT_CHANGED,
             std::string summary = NOT_CHANGED, std::string director = NOT_CHANGED);
    void delete_(int id);
    void rate(int id, int score);
    void comment(int id, std::string content);
    void delete_comment(int film_id, int comment_id);
    void reply(int film_id, int comment_id, std::string content);
    std::vector <Film> get_purchased();
    std::vector <Film> get_published();
    std::vector <Film> get_all_films();
    std::vector <Film> get_recommendation_list(Film refferin_film);

private:
    DataBase* database;
    UserSessionManagement* user_manager;
    void check_edit_access(int id);
    void check_client_access(int film_id);
    void send_film_add_notif(std::vector <int> followers_id);
    void buy_film(int film_id);
    int calculate_publisher_part(float rate, int price);
    Notification new_film_notification(Publisher publisher);
    Notification rate_notification(Client client, Film film);
    Notification buy_notification(Client client, Film film);
    Notification comment_notification(Client client, Film film);
    Notification reply_notification(Publisher publisher);

};

#endif#ifndef FOLLOWER_CONTROLLER_H
#define FOLLOWER_CONTROLLER_H

#include <vector> 

#include "Controller.h"
#include "UserService.h"

class FollowerController :public Controller
{
public:
    virtual Response post(Request* request);
    virtual Response get(Request* request);
private:
    UserService user_service;
    Response get_follower_response(std::vector <const Client*> clients);
};

#endif#ifndef LOGIN_CONTROLLER_H
#define LOGIN_CONTROLLER_H

#include "Controller.h"
#include "Response.h"

class LoginController :public Controller
{
    public:
        virtual Response post(Request* request);
    private:
        virtual void post_required_params();
};

#endif/* MD5
 converted to C++ class by Frank Thilo (thilo@unix-ag.org)
 for bzflag (http://www.bzflag.org)
 
   based on:
 
   md5.h and md5.c
   reference implementation of RFC 1321
 
   Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
 
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
 
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
 
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
 
These notices must be retained in any copies of any part of this
documentation and/or software.
 
*/
 
#ifndef BZF_MD5_H
#define BZF_MD5_H
 
#include <cstring>
#include <iostream>
 
 
// a small class for calculating MD5 hashes of strings or byte arrays
// it is not meant to be fast or secure
//
// usage: 1) feed it blocks of uchars with update()
//      2) finalize()
//      3) get hexdigest() string
//      or
//      MD5(std::string).hexdigest()
//
// assumes that char is 8 bit and int is 32 bit
class MD5
{
public:
  typedef unsigned int size_type; // must be 32bit
 
  MD5();
  MD5(const std::string& text);
  void update(const unsigned char *buf, size_type length);
  void update(const char *buf, size_type length);
  MD5& finalize();
  std::string hexdigest() const;
  friend std::ostream& operator<<(std::ostream&, MD5 md5);
 
private:
  void init();
  typedef unsigned char uint1; //  8bit
  typedef unsigned int uint4;  // 32bit
  enum {blocksize = 64}; // VC6 won't eat a const static int here
 
  void transform(const uint1 block[blocksize]);
  static void decode(uint4 output[], const uint1 input[], size_type len);
  static void encode(uint1 output[], const uint4 input[], size_type len);
 
  bool finalized;
  uint1 buffer[blocksize]; // bytes that didn't fit in last 64 byte chunk
  uint4 count[2];   // 64bit counter for number of bits (lo, hi)
  uint4 state[4];   // digest so far
  uint1 digest[16]; // the result
 
  // low level logic operations
  static inline uint4 F(uint4 x, uint4 y, uint4 z);
  static inline uint4 G(uint4 x, uint4 y, uint4 z);
  static inline uint4 H(uint4 x, uint4 y, uint4 z);
  static inline uint4 I(uint4 x, uint4 y, uint4 z);
  static inline uint4 rotate_left(uint4 x, int n);
  static inline void FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);
  static inline void GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);
  static inline void HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);
  static inline void II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac);
};
 
std::string md5(const std::string str);
 
#endif
#ifndef MONEY_CONTROLLER_H
#define MONEY_CONTROLLER_H

#include "Controller.h"

class MoneyController :public Controller
{
public:
    virtual Response post(Request* request);
};

#endif#ifndef NOTIFICATION_H
#define NOTIFICATION_H

#include <string>

class Notification 
{
    Notification(std::string content);
    bool is_read();
private:
    std::string content;
    bool read;
};


#endif#ifndef NOTIFICATIONS_CONTROLLER_H
#define NOTIFICATIONS_CONTROLLER_H

#include <string>
#include <vector>

#include "Controller.h"

#define NO_LIMIT -1

class NotificationsController: public Controller
{
public:
    virtual Response get(Request* request);
protected:
    Response make_notification_response(std::vector <std::string> notifs, int limit = NO_LIMIT);
};

#endif
#ifndef NOTIFICATIONS_READ_CONTROLLER_H
#define NOTIFICATIONS_READ_CONTROLLER_H

#include "NotificationsController.h"

class NotificationsReadController: public NotificationsController
{
public:
    virtual Response get(Request* request);
private:
    int limit;
};

#endif#ifndef PUBLISHED_CONTROLLER_H
#define PUBLISHED_CONTROLLER_H

#include "FilmFilterController.h"

class PublishedController: public FilmFilterController
{
public:
    virtual Response get(Request* request);
protected:
    virtual void check_params();
};

#endif#ifndef PUBLISHER_H
#define PUBLISHER_H

#include "Client.h"

#include <map>

class Film;

class Publisher: public Client
{
public:
    Publisher(std::string email, std::string username, std::string password, int age);
    void add_film(Film* film);
    void delete_film(int film_id);
    bool film_is_published_by_user(int film_id) const;
    void add_follower(int id);
    std::vector <int> get_followers() const;
    void reply_comment(int film_id, int comment_id);
    void sell_film(int publisher_part);
    int get_debt();
    void pay_debt();
    std::vector <Film> get_published();
protected:
    int debt;
    std::map <int, Film*> published;
    std::vector <int> followers;
};

#endif#ifndef PURCHASED_CONTROLLER_H
#define PURCHASED_CONTROLLER_H

#include "FilmFilterController.h"


class PurchasedController :public FilmFilterController
{
public:
    virtual Response get(Request* request);
private: 
    int nothing;
};

#endif#ifndef RATE_CONTROLLER_H
#define RATE_CONTROLLER_H

#include "Controller.h"

class RateController: public Controller 
{
public:
    virtual Response post(Request* request);
private:   
    int film_id;
    int score;
    void check_post_params();
};

#endif#ifndef REPLIES_CONTROLLER_H
#define REPLIES_CONTROLLER_H

#include <string>

#include "Controller.h"

class RepliesController:public Controller
{
public: 
    virtual Response post(Request* request);
private:
    int film_id;
    int comment_id;
    std::string content;
    void check_post_params();
};

#endif
#ifndef REQUEST_H
#define REQUEST_H

#include <string>
#include <vector>
#include <map>

enum METHODS {GET, PUT, POST, DELETE};

#define GET_ "GET"
#define PUT_ "PUT"
#define DELETE_ "DELETE"
#define POST_ "POST"

#define SIGN_UP "signup"
#define LOGIN "login"
#define FILMS "films"
#define PUBLISHED "published"
#define REPLIES "replies"
#define COMMENTS "comments"
#define FOLLOWERS "followers"
#define MONEY "money"
#define BUY "buy"
#define RATE "rate"
#define PURCHASED "purchased"
#define NOTIFICATION "notifications"
#define NOTIFICATION_READ "notifications read"

class Request
{
public:
    Request(std::vector<std::string>);
    void print_request(); //this should be deleted
    std::string get_request_param(std::string);
    int get_method();
    std::string get_url();
    int number_of_params();
private:
    int method;
    std::string url;
    std::map <std::string, std::string> parameters;
};


#endif#ifndef REQUEST_RECIEVER
#define REQUEST_RECIEVER

class Request;

#include <string>
#include <vector>

#include "Request.h"

class RequestReciever 
{
public:
    Request recieve_request();

private:
    std::string request_line;
    std::vector <std::string> parse_request();
    void control_format(std::vector<std::string> request_tokens);
    bool check_valid_token(std::string token, std::vector <std::string> valid_tokens);
    bool valid_token(std::string token, std::vector <std::string> valid_tokens);

};

#endif#ifndef RESPONSE_H
#define RESPONSE_H

#include <string>

enum res_type{SUCCESSFUL, ERROR, EMPTY};
#define OK "OK"

class Response
{
public:
    Response(int type, std::string content);
    Response();
    std::string get_content() {return content;};
    friend std::ostream& operator<<(std::ostream&, const Response& respones);
protected:
    int type;
    std::string content;
};

#endif#ifndef SIGNUP_CONTROLLER_H
#define SIGNUP_CONTROLLER_H

#include "Controller.h"

class SignupController: public Controller
{
public:
    virtual Response post(Request* request);

protected:
    std::string username;
    std::string password;
    std::string email;
    int age;
    bool publisher_flag;
    void post_required_params();
    bool is_publisher();

};


#endif#ifndef USER_H
#define USER_H


#include <string>
#include <vector>

enum UserType {ADMIN, CLIENT, PUBLISHER};


class User
{
public:
    User(std::string username, std::string password);
    bool valid_login(std::string username, std::string password);

    std::string get_username() const;
    int get_id() const;
    virtual int get_type() const;

protected:
    // static int type;
    int id;
    std::string email;
    std::string username;
    std::string password;
};


#endif#ifndef USER_SERVICE_H
#define USER_SERVICE_H

#include <vector>

#include "Request.h"


#define USER_ID "user_id"
#define USERNAME "username"
#define PASSWORD "password"
#define EMAIL "email"
#define AGE "age"
#define PUBLISHER_PARAM "publisher"



class Response;
class DataBase;
class UserSessionManagement;
class Client;

typedef std::string Notification;

class UserService
{
public:
    UserService();
    void signup(std::string email, std::string username, std::string password, int age, bool publisher);
    void login(std::string username, std::string password);
    void follow(int publisher_id);
    std::vector <const Client*> get_followers();
    std::vector <Notification> get_notifications(bool read = false);
private:
    DataBase* database;
    UserSessionManagement* user_manager;
    Notification follow_notification(Client follower);
    

};

#endif#ifndef SESSION_MANAGEMENT_H
#define SESSION_MANAGEMENT_H

class User;
class Client;
class Publisher;

class UserSessionManagement 
{
public:
    static UserSessionManagement* get_instance();
    void set_logged_user(User* logged_user);
    User* get_logged_user();
    Publisher* get_logged_publisher();
    Client* get_logged_client();
    bool is_publisher();
    bool is_admin();
private:
    // UserSessionManagement() = default;
    static UserSessionManagement* instance;
    User* logged_user;
};

#endif#ifndef UT_FLIX_H
#define UT_FLIX_H

#include <string>

#include "Publisher.h"

class DataBase;
class Controller;
class RequestReciever;


class UTflix 
{
public:
    static UTflix* get_instance();
    void pay_publisher_debt(Publisher* publisher);
    void add_credit(int amount);
    ~UTflix();
private:
    UTflix() = default;
    static UTflix* instance;
    int credit;

};


#endif#ifndef UTILS_H
#define UTILS_H

#include <string>
#include <vector>

#define NOT_FOUND -1

class Utils 
{
public:
    Utils() {};
    static int find(std::string word, std::vector <std::string> sentence);
    static std::vector <std::string> merge_tokens(int from, int to, std::vector <std::string> words);
    static std::vector <std::string> split_line(std::string line, std::string delimiters);
    static bool is_in_string(char character, std::string checkString);
    static bool is_valid_email(std::string email);
    static bool is_valid_number(std::string number);
    static int string_integer_value(std::string number);
// private:
    // int something_alaki;

};

#endif#include "BuyController.h"

#include "FilmService.h"
#include "Film.h"
#include "Exceptions.h"
#include "Publisher.h"
#include "Utils.h"

#define FILM_ID "film_id"

Response BuyController::post(Request* request)
{
    current_request = request;
    check_post_params();
    FilmService film_service;
    film_service.buy(film_id);

    return Response(SUCCESSFUL, OK);
}

void BuyController::check_post_params()
{
    try
    {
        film_id = Utils::string_integer_value(current_request->get_request_param(FILM_ID));
    }
    catch(NotFound& er)
    {
        throw BadRequest("required params do not exist");
    }
}#include "Client.h"
#include <iostream>

#include "Exceptions.h"

#include "Publisher.h"
#include "Film.h"

using namespace std;

int Client::last_id_created = 0;

Client::Client(string _email, string _username, string _password, int _age)
    :User(_username, _password), email(_email), age(_age)
{
    last_id_created++;
    id = last_id_created;
}


void Client::follow(Publisher* following)
{
    if (followings.find(following->get_id()) == followings.end())
        followings.insert(pair <int, const Publisher*> (following->get_id(), following));
    else 
        throw BadRequest("this publisher is already followed");
}

void Client::increase_credit(int amount)
{
    credit += amount;
}

void Client::purchase_film(Film* film)
{
    if (credit < film->get_price());
        throw PermissionDenied("not enough money");
    if (purchased.find(film->get_id()) != purchased.end())
        throw BadRequest("film is already purchased");

    credit -= film->get_price();
    purchased.insert(pair <int, Film*> (film->get_id(), film));
}

void Client::send_notif(Notification new_notif)
{
    notifications.push_back(new_notif);
}

bool Client::is_purchased(int film_id) const
{
    if (purchased.find(film_id) == purchased.end())
        return false;
    else
        return true;
    
}


int Client::get_type() const
{
    return CLIENT;
}



std::string Client::get_email() const
{
    return email;
}


vector <Notification> Client::get_notification()
{
    vector <Notification> res = notifications;
    for (int i = 0; i < notifications.size(); i++)
    {
        read_notification.push_back(notifications[i]);
    }
    notifications.clear();
    return res;
}


vector <Notification> Client::get_read_notification()
{
    return read_notification;
}

// vector <const Film*> Client::get_purchased()
// {
//     return purchase_film
// }


#include "Comment.h"

Comment::Comment(int _id, int _writer_id, std::string _content)
    :id(_id), writer_id(_writer_id), content(_content)
{

}

void Comment::add_reply(std::string _reply)
{
    reply.push_back(_reply);
}


int Comment::get_id() const 
{
    return id;
}

int Comment:: get_writer_id()
{
    return writer_id;
}

std::vector <std::string> Comment::get_reply() const
{
    return reply;
}

std::string Comment::get_content() const
{
    return content;
}




#include "CommentsController.h"

#include "Request.h"
#include "Response.h"
#include "FilmService.h"
#include "Utils.h"
#include "Exceptions.h"


Response CommentsController::post(Request* request)
{
    current_request = request;
    FilmService film_service;
    check_post_params();
    film_service.comment(film_id, content);

    return Response(SUCCESSFUL, OK);

}


Response CommentsController::delete_(Request* request)
{
    current_request = request;
    FilmService film_service;
    check_delete_params();
    film_service.delete_comment(film_id, comment_id);

    return Response(SUCCESSFUL, OK);
}

void CommentsController::check_post_params()
{
    try
    {
        film_id = Utils::string_integer_value(current_request->get_request_param(FILM_ID));
        content = current_request->get_request_param(CONTENT);
    }
    catch(NotFound& er)
    {
        throw BadRequest("required params do not exist");
    }
}

void CommentsController::check_delete_params()
{
    try
    {
        film_id = Utils::string_integer_value(current_request->get_request_param(FILM_ID));
        comment_id = Utils::string_integer_value(current_request->get_request_param(COMMENT_ID));
    }
    catch(NotFound& er)
    {
        throw BadRequest("required params do not exist");
    }
    
}#include "Controller.h"

#include "Response.h"
#include "Exceptions.h"

Controller::Controller()
{
    current_request = NULL;
}

Response Controller::put(Request* request)
{
    return Response(ERROR, BadRequest("not matching method and url").error());
}

Response Controller::get(Request* request)
{
    return Response(ERROR, BadRequest("not matching method and url").error());
}

Response Controller::post(Request* request)
{
    return Response(ERROR, BadRequest("not matching method and url").error());
}

Response Controller::delete_(Request* request)
{
    return Response(ERROR, BadRequest("not matching method and url").error());
}#include "ControllerManager.h"

#include <iostream> //delete it 

#include "SignupController.h"
#include "LoginController.h"
#include "FilmController.h"
#include "FollowerController.h"
#include "MoneyController.h"
#include "BuyController.h"
#include "CommentsController.h"
#include "RepliesController.h"
#include "RateController.h"
#include "NotificationsController.h"
#include "Exceptions.h"
#include "Response.h"

using namespace std;

ControllerManager::ControllerManager()
{
    controllers.insert(pair <std::string, Controller*> (SIGN_UP, new SignupController()));
    controllers.insert(pair <std::string, Controller*> (LOGIN, new LoginController()));
    controllers.insert(pair <std::string, Controller*> (FILMS, new FilmController()));
    controllers.insert(pair <std::string, Controller*> (FOLLOWERS, new FollowerController()));
    controllers.insert(pair <std::string, Controller*> (MONEY, new MoneyController()));
    controllers.insert(pair <std::string, Controller*> (COMMENTS, new CommentsController()));
    controllers.insert(pair <std::string, Controller*> (REPLIES, new RepliesController()));
    controllers.insert(pair <std::string, Controller*> (BUY, new BuyController()));
    controllers.insert(pair <std::string, Controller*> (RATE, new RateController()));

    
}

ControllerManager::~ControllerManager()
{
    for (map <std::string, Controller*> ::iterator it = controllers.begin(); it != controllers.end(); it++)
        delete (it->second);
}

void ControllerManager::run_controller(Request* request)
{
    response = Response();
    Controller* controller = controllers[request->get_url()];
    switch (request->get_method())
    {
        case GET:
            response = controller->get(request);
            break;
        case POST:
            response = controller->post(request);
            break;            
        case PUT:
            response = controller->put(request);
            break;
        case DELETE:
            response = controller->delete_(request);
            break;
    }
}

Response ControllerManager::get_response()
{
    return response;
}#include "DataBase.h"

#include "Client.h"
#include "User.h"
#include "Film.h"
#include "Exceptions.h"

using namespace std;

DataBase* DataBase::instance = nullptr;

DataBase* DataBase::get_instance()
{
    if (instance == nullptr)
        instance = new DataBase();
    return instance;
}

DataBase::~DataBase()
{
    for (map <int, Client*> ::iterator it = clients.begin() ; it != clients.end(); it++)
        delete it->second;
}


void DataBase::add_client(Client* new_user)
{
    if (valid_username(new_user->get_username())
            && clients.find(new_user->get_id()) == clients.end())
    {
        clients.insert(pair <int, Client*> (new_user->get_id(), new_user));
        id.insert(pair<string, int> (new_user->get_username(), new_user->get_id()));
    }
    else 
    {
        delete new_user;
        throw BadRequest("user name and id already exist");
    }
}

void DataBase::add_film(Film* new_film)
{
    if (films.find(new_film->get_id()) == films.end())
        films.insert(pair <int, Film*> (new_film->get_id(), new_film));
}

Client* DataBase::search_client(int id)
{
    if (clients.find(id) != clients.end())
        return clients[id];
    
    else
        throw new NotFound("not found in database");
}

Client* DataBase::search_client(std::string username)
{
    if(id.find(username) != id.end())
        return search_client(id[username]);
}


Film* DataBase::search_film(int film_id)
{
    if (films.find(film_id) != films.end())
        return films[film_id];
    else 
        throw new NotFound("film not found in data base");
}



vector <Film> DataBase::get_all_films()
{
    vector <Film> res;
    for (map <int, Film*>:: iterator it = films.begin(); it != films.end(); it++)
    {
        if (it->second->is_available())
            res.push_back(*(it->second));
    }

    return res;
}

bool DataBase::film_exist(int id)
{
    return films.find(id) != films.end();
}

bool DataBase::client_exist(int id)
{
    return clients.find(id) != clients.end();
}

bool DataBase::valid_username(string username)
{
    return id.find(username) == id.end();
}
//entities must add toghether or one by one



#include <string>

#include "Exceptions.h"


using namespace std;

Exception::Exception(std::string _description)
    :exception(), description(_description)
{}


const string BadRequest::error() const throw()
{
    string response = "Bad Request";
    response += "  details:  " + description;
    return response;

}

const string NotFound::error() const throw()
{
    string response = "Not Found";
    response += "  details:  " + description;
    return response.c_str();
}



const string PermissionDenied::error() const throw()
{
    string response = "Permission Denied";
    response += "  details:  " + description;
    return response.c_str();
}

const char* BadRequest::what() const throw()
{
    return "Bad Request";

}

const char* NotFound::what() const throw()

{
    return "Not Found";
}



const char* PermissionDenied::what() const throw()
{
    return "Permissoin Denied";
}

#include "FilmController.h"

#include <string>
#include <sstream>

#include "FilmService.h"
#include "FilmFilterController.h"
#include "Utils.h"
#include "Response.h"
#include "Exceptions.h"
#include "Comment.h"
#include "DataBase.h"
#include "UserSessionManagement.h"

#define FILM_ID "film_id"
#define NAME "name"
#define YEAR "year"
#define LENGTH "length"
#define PRICE "price"
#define SUMMERY "summary"
#define DIRECTOR "director"

using namespace std;

FilmController::FilmController()
{}

Response FilmController::get(Request* request)
{
    re_initialize();
    current_request = request;
    if (get_id_param_exist())
    {
        Film film = *DataBase::get_instance()->search_film(id);
        string film_info = make_film_info_string(film);
        string comments_info = make_comments_string(film);
        string recoms_info = make_recommendation_string(film);

        return Response(SUCCESSFUL, film_info + comments_info + recoms_info);
    }
    else
    {   
        FilmFilterController film_filter_controller;
        return film_filter_controller.get(request); 
    }

}

bool FilmController::get_id_param_exist()
{
    try{
        id = Utils::string_integer_value(current_request->get_request_param(FILM_ID));
        return true;
    }
    catch(NotFound& er)
    {
        return false;
    }
}

Response FilmController::post(Request* request)
{
    re_initialize();
    current_request = request;
    try
    {
        film_service.add_film(name, year, length, price, summary, director);
        return Response(SUCCESSFUL, OK);
    }
    catch(Exception& er)
    {
        return Response(ERROR, er.error());
    }
}

void FilmController::post_required_params()
{
    name = current_request->get_request_param(NAME);
    string year_string = current_request->get_request_param(YEAR);
    string length_string = current_request->get_request_param(LENGTH);
    string price_string = current_request->get_request_param(PRICE);
    summary = current_request->get_request_param(SUMMERY);
    director = current_request->get_request_param(DIRECTOR);

    if (Utils::is_valid_number(year_string) && Utils::is_valid_number(length_string)
             && Utils::is_valid_number(price_string))
        
    {
        year = stoi(year_string);
        length = stoi(length_string);
        price = stoi(price_string);
        if (year < 0 && length < 0 && price < 0)
            throw BadRequest("numbers are not valid");
    }
    else 
        throw BadRequest("numbers are not a number");   
}


Response FilmController::put(Request* request)
{
    current_request = request;
    put_params();
    film_service.edit_film(id, name, year, length, summary, director);
    return Response(SUCCESSFUL, OK);
}

Response FilmController::delete_(Request* request)
{
    re_initialize();
    current_request = request;
    set_id_param();
    film_service.delete_(id);
    Response(SUCCESSFUL, OK);
}

void FilmController::put_params()
{
    re_initialize();

    string year_string, length_string;

    set_id_param();
    try{name = current_request->get_request_param(NAME);}
    catch(NotFound) {}

    try{summary = current_request->get_request_param(SUMMERY);}
    catch(NotFound) {}

    try{director = current_request->get_request_param(DIRECTOR);}
    catch(NotFound) {}    

    try{
        year_string = current_request->get_request_param(YEAR);
        year = Utils::string_integer_value(year_string);
    }
    catch(NotFound) {}

    try{
        length_string = current_request->get_request_param(LENGTH);
        length = Utils::string_integer_value(length_string);
    }
    catch(NotFound) {}
}

void FilmController::re_initialize()
{
    name = NOT_CHANGED;
    year = VALUE_NOT_CHANGED;
    length = VALUE_NOT_CHANGED;
    price = VALUE_NOT_CHANGED;
    summary = NOT_CHANGED;
    director = NOT_CHANGED;
}

void FilmController::set_id_param()
{
    try {
        if (!Utils::is_valid_number(current_request->get_request_param(FILM_ID)))
        throw BadRequest("id is not a number");
        id = stoi(current_request->get_request_param(FILM_ID));
    }
    catch(NotFound)
    {
        throw BadRequest("film id parameter not found");
    }
}

string FilmController::make_film_info_string(Film film)
{

    stringstream film_info;
    film_info << "Details of Film " << film.get_name() << endl
            << "Id = " << film.get_id() << endl
            << "Director = " << film.get_director() << endl
            << "Length = " << film.get_length() << endl
            << "Year = " << film.get_year() << endl
            << "Rate = " << film.get_rate() << endl
            << "Price = " << film.get_price() << endl;

    return film_info.str();
}

string FilmController::make_recommendation_string(Film film)
{
    const int RECOM_SIZE = 4;
    const string spacer = " | ";
    vector <Film> recoms = film_service.get_recommendation_list(film);
    FilmFilterService recom_filter(recoms);
    recom_filter.filter_purchased(film_service.get_purchased());
    recoms = recom_filter.get_filtered();
    stringstream recom;
    recom << "Recommendation Film" << endl;
    recom << "#. Film Id" << spacer << "Film Name" << spacer << "Film Length" << spacer << "Film Director" << endl;
    for (int i = 0; i < RECOM_SIZE; i++)
        recom << recoms[i].get_id() << spacer << recoms[i].get_name() << spacer 
                << recoms[i].get_length() << spacer << recoms[i].get_director() << endl;
    
    return recom.str();
}

string FilmController::make_comments_string(Film film)
{
    stringstream comment_info;
    vector <Comment> comments = film.get_comments();
    comment_info << "Comments" << endl;
    for (int i = 0; i < comments.size(); i++)
    {
        comment_info << comments[i].get_id() << ". " << comments[i].get_content() << endl;
        vector <string> replies = comments[i].get_reply();
        for (int j = 0; j < replies.size(); j++)
            comment_info << comments[i].get_id() << j + 1 << replies[j] << endl;
    }

    return comment_info.str();
}#include "Film.h"

#include "Exceptions.h"
#include "Comment.h"

enum {MIN_SCORE = 0, MAX_SCORE = 10};

using namespace std;

int Film::last_id_created = 0;

Film::Film(string _name, int _year, int _length, int _price, string _summary, string _director, int _publisher_id)
    : name(name), year(_year), length(_length), summary(_summary), director(_director), available(true), publisher_id(_publisher_id)
{
    last_id_created++;
    id = last_id_created;
    last_comment_id = 0;
    rate = 0;
}

void Film::delete_()
{
    available = false;
}

bool Film::is_available()
{
    return available;
}

void Film::add_comment(std::string content, int writer_id)
{
    last_comment_id++;
    comments[last_comment_id] = Comment(last_comment_id, writer_id,  content);
}


void Film::reply_comment(int comment_id, string reply_content)
{
    if(comments.find(comment_id) == comments.end())
        throw new NotFound("comment id not found");
    else
        comments[comment_id].add_reply(reply_content);
}

void Film::delete_comment(int comment_id)
{
    if(comments.find(comment_id) == comments.end())
        throw new NotFound("comment id not found");
    else
        comments.erase(comment_id); 
}

void Film::add_score(int score)
{
    if (score >= MIN_SCORE && score <= MAX_SCORE)
        scores.push_back(score);
    else
        throw BadRequest("rate range is not right");
}


void Film::set_name(string _name)
{
    name = _name;
}

string Film::get_name()
{
    return name;
}

void Film::set_year(int _year)
{
    year = _year;
}


int Film::get_year()
{
    return year;
}

void Film::set_length(int _length)
{
    year = _length;
}


int Film::get_length()
{
    return length;
}

void Film::set_summary(string _summary)
{
    summary = _summary;
}

string Film::get_summary()
{
    return summary;
}

void Film::set_director(string _director)
{
    director = _director;
}

string Film::get_director()
{
    return director;
}

int Film::get_price()
{
    return price;
}

int Film::get_id()
{
    return id;
}

float Film::get_rate()
{
    float _rate = 0;
    int sum;
    for (int i = 0; i < scores.size(); i++)
        sum += scores[i];
    
    rate = ((float) sum ) / scores.size();
    return rate;
}

int Film::get_publisher_id()
{
    return publisher_id;
}

int Film::get_commenter_id(int comment_id)
{
    if (comments.find(comment_id) != comments.end())
        return comments[comment_id].get_writer_id();
}

vector <Comment> Film::get_comments()
{
    vector <Comment> res;
    for (map <int, Comment>:: iterator it = comments.begin(); it != comments.end(); it++)
    {
        res.push_back(it->second);
    }

    return res;
}









#include "FilmFilterController.h"

#include <sstream>

#include "Request.h"
#include "Response.h"
#include "Exceptions.h"
#include "FilmFilterService.h"
#include "UserSessionManagement.h"
#include "FilmService.h"
#include "DataBase.h"
#include "Utils.h"


#define MIN_YEAR "min_year"
#define MAX_YEAR "max_year"
#define PRICE "price"
#define DIRECTOR "director"

Response FilmFilterController::get(Request* request)
{
    current_request = request;
    check_params();
    FilmFilterService film_filter(DataBase::get_instance()->get_all_films);
    film_filter.filter(name , max_year, min_year, price, rate, director);
    films = film_filter.get_filtered();
    return make_get_film_respnse();
}


Response FilmFilterController::make_get_film_response()
{
    const string film_header = "#. Film Id | Film Name | Film Length | Film price | Rate | Production Year | Film Director";
    const string spacer = " | ";
    stringstream res;

    for (int i = 0; i < films.size(); i++)
    {
        res << i + 1 << ". " << films[i].get_id() << spacer << films[i].get_name() << spacer << films[i].get_length()
                 << spacer << films[i].get_price() << spacer << films[i].get_rate() << spacer << films[i].get_year()
                 << spacer << films[i].get_director() << endl;
    }
    
    return Respnse(SUCCESSFUL, res.str());
}


void FilmFilterController::check_params()
{
    re_initialize_params();
    try
    {name = current_request->get_request_param(NAME);}
    catch(NotFound& er)
    {}
     
    try 
    {director = current_request->get_request_param(DIRECTOR);}
    catch(NotFound& er)
    {}

    try
    {min_year = Utils::string_integer_value(current_request->get_request_param(MIN_YEAR));}
    catch(NotFound& er)
    {}

    try
    {max_year = Utils::string_integer_value(current_request->get_request_param(MAX_YEAR));}
    catch(NotFound& er)
    {}

    try
    {price = Utils::string_integer_value(current_request->get_request_param(PRICE));}
    catch(NotFound& er)
    {}    
}

void FilmFilterController::re_initialize_params()
{
    name = NOT_FILTERED_ST;
    director = NOT_FILTERED_ST;
    min_year = NOT_FILTERED;
    max_year = NOT_FILTERED;
    price = NOT_FILTERED;
    rate = NOT_FILTERED;
}#include "FilmFilterService.h"

#include <algorithm>

using namespace std;

void FilmFilterService::filter_by_name(string name)
{
    vector <Film> filtered;
    for (int i = 0; i < films.size(); i++)
    {
        if (films[i].get_name() == name)
            filtered.push_back(films[i]);
    }

    films = filtered;
}  

void FilmFilterService::filter_by_director(string director)
{
    vector <Film> filtered;
    for (int i = 0; i < films.size(); i++)
    {
        if (films[i].get_director() == director)
            filtered.push_back(films[i]);
    }

    films = filtered;
}   

void FilmFilterService::filter_by_max_year(int max_year)
{
    vector <Film> filtered;
    for (int i = 0; i < films.size(); i++)
    {
        if (films[i].get_year() <= max_year)
            filtered.push_back(films[i]);
    }

    films = filtered;
}   

void FilmFilterService::filter_by_max_year(int min_year)
{
    vector <Film> filtered;
    for (int i = 0; i < films.size(); i++)
    {
        if (films[i].get_year() >= min_year)
            filtered.push_back(films[i]);
    }

    films = filtered;
}

void FilmFilterService::filter_by_price(int price)
{
    vector <Film> filtered;
    for (int i = 0; i < films.size(); i++)
    {
        if (films[i].get_price() == price)
            filtered.push_back(films[i]);
    }

    films = filtered;
}

void FilmFilterService::filter_by_min_rate(float min_rate)
{
    vector <Film> filtered;
    for (int i = 0; i < films.size(); i++)
    {
        if (films[i].get_rate() >= min_rate)
            filtered.push_back(films[i]);
    }

    films = filtered;
}   

void FilmFilterService::stable_sort_by_rate()
{
    stable_sort(films.begin(), films.end(), compare_by_rate);
}

void FilmFilterService::filter_purchased(vector <Film> purchased_ids)
{
    vector <Film> filtered;
    for (int j = 0; j < purchased_ids.size(); j++)
    {
        for (int i = 0; i < films.size(); i++)
        {
            if (films[i].get_id() != purchased_ids[j].get_id())
                filtered.push_back(films[i]);
        }
    }

    films = filtered;  
}

void FilmFilterService::filter_not_available()
{
    vector <Film> filtered;
    for (int i = 0; i < films.size(); i++)
    {
        if (films[i].is_available())
            filtered.push_back(films[i]);
    }

    films = filtered;
}

vector <Film> FilmFilterService::get_filtered()
{
    return films;
}

bool FilmFilterService::compare_by_rate(Film first, Film second)
{
    return (first.get_rate() < second.get_rate());
}
#include "FilmService.h"

#include <string>
#include <sstream>

#include "DataBase.h"
#include "UserSessionManagement.h"
#include "Publisher.h"
#include "Film.h"
#include "Exceptions.h"
#include "UTflix.h"
#include "FilmFilterService.h"

enum {WEAK = 80, MEDIUM = 90, HIGH = 95};

#define WEAK_BORDER 5.0
#define HIGH_BORDER 8.0

#define USER_ST "User "
#define PUBLISHER_ST "Publisher "
#define WITH_ID " with id "

using namespace std;


FilmService::FilmService()
{
    user_manager = UserSessionManagement::get_instance();
    database = DataBase::get_instance();
}

void FilmService::buy(int film_id)
{
    Client* client = UserSessionManagement::get_instance()->get_logged_client();
    Film* film = DataBase::get_instance()->search_film(film_id);
    Publisher* publisher = dynamic_cast <Publisher*> (DataBase::get_instance()->search_client(film->get_publisher_id()));
    if (film->is_available())
    {
        client->purchase_film(film);
        publisher->sell_film(calculate_publisher_part(film->get_rate(), film->get_price()));
    }
    else
        throw NotFound("film is not available");
}

void FilmService::add_film(string name, int year, int length, int price, string summary, string director)
{
    Publisher* publisher = user_manager->get_logged_publisher();
    Film* new_film = new Film(name, year, length, price, summary, director, publisher->get_id());
    database->add_film(new_film);
    publisher->add_film(new_film);
    send_film_add_notif(publisher->get_followers());
}

void FilmService::edit_film(int id, string _name, int _year,int _length, string _summary, string _director)
{
    string name, summary, director;
    int  length, year;
    Film* film = database->search_film(id);
    check_edit_access(id);

    if (name != NOT_CHANGED)
        film->set_name(name);
    if (summary != NOT_CHANGED)
        film->set_summary(summary);
    if (director != NOT_CHANGED)
        film->set_director(director);
    if (year != VALUE_NOT_CHANGED)
        film->set_year(year); 
    if (length != VALUE_NOT_CHANGED)
        film->set_length(length);   
}

void FilmService::delete_(int id)
{
    Film* film = database->search_film(id);
    check_edit_access(id);
    film->delete_();
}

void FilmService::rate(int id, int score)
{
    Film* film = database->search_film(id);
    Client* client = user_manager->get_logged_client();
    check_client_access(id);
    
    film->add_score(score);
    Client*  publisher = database->search_client(film->get_publisher_id());
    publisher->send_notif(rate_notification(*client, *film));

}

void FilmService::comment(int id, std::string content)
{
    Film* film = database->search_film(id);
    Client* client = user_manager->get_logged_client();
    check_client_access(id);

    film->add_comment(content, client->get_id());
    Client*  publisher = database->search_client(film->get_publisher_id());
    publisher->send_notif(comment_notification(*client, *film));
}

void FilmService::delete_comment(int film_id, int comment_id)
{
    Film* film = database->search_film(film_id);
    check_edit_access(film_id);
    film->delete_comment(comment_id);
}

void FilmService::reply(int film_id, int comment_id, std::string content)
{
    Film* film = database->search_film(film_id);
    Publisher* publisher = dynamic_cast <Publisher*> (database->search_client(film->get_publisher_id()));
    check_edit_access(film_id);
    film->reply_comment(comment_id, content);

    Client* commenter = database->search_client(film->get_commenter_id(comment_id));
    commenter->send_notif(reply_notification(*publisher));
}

std::vector <Film> FilmService::get_purchased()
{
    Client* client = user_manager->get_logged_client();
    vector <Film> res;
    vector <int> film_id = client->get_purchased();
    for (int i = 0; i < film_id.size(); i++)
        res.push_back(*(database->search_film(film_id[i])));
    
    return res;
}

std::vector <Film> FilmService::get_published()
{
    Publisher* pub = user_manager->get_logged_publisher();
    return pub->get_published();
}

vector <Film> FilmService::get_recommendation_list(Film reffering_film)
{
    FilmFilterService film_filter(database->get_all_films());
    film_filter.stable_sort_by_rate();
    vector <Film> films = film_filter.get_filtered();
    vector <Film> recoms;
    int size = films.size();
    for (int i = size - 1; i >= 0 && i >= 0; i--)
    {   
        if (reffering_film.get_id() != films[i].get_id())
            recoms.push_back(films[i]);
    }

    return recoms;
}



void FilmService::check_edit_access(int id)
{
    Publisher* publisher = user_manager->get_logged_publisher();
    if (!publisher->film_is_published_by_user(id))
        throw PermissionDenied("this film doesn't belong to this user");
    
}

void FilmService::check_client_access(int film_id)
{
    Client* client = user_manager->get_logged_client();
    if (!client->is_purchased(film_id))
        throw PermissionDenied("this client didn't buy this film");
}

void FilmService::send_film_add_notif(vector <int> followers_id)
{
    string notif;
    Publisher* publisher_user = user_manager->get_logged_publisher();
    notif = new_film_notification(*publisher_user);
    for (int i = 0; i < followers_id.size(); i++)
    {
        Client* follower = database->search_client(followers_id[i]);
        follower->send_notif(notif);
    }

}

void FilmService::buy_film(int film_id)
{
    Client* client = user_manager->get_logged_client();
    Film* film = database->search_film(film_id);
    int publisher_id = film->get_publisher_id();
    Publisher* publisher = dynamic_cast <Publisher*> (database->search_client(publisher_id));

    if (film->is_available())
    {
        client->purchase_film(film);
        int publisher_share = calculate_publisher_part(film->get_rate(), film->get_price());
        publisher->sell_film(publisher_share);
        publisher->send_notif(buy_notification(*client, *film));
    }
    else
        throw NotFound("film is not available");
}



int FilmService::calculate_publisher_part(float rate, int price)
{
    if (rate < WEAK_BORDER)
        return price * WEAK / 100;
    
    if (rate >= WEAK_BORDER && rate < HIGH_BORDER)
        return price * MEDIUM / 100;

    if (rate >= HIGH_BORDER)
        return price * HIGH / 100;

}

Notification FilmService::new_film_notification(Publisher publisher)
{
    stringstream notif;
    notif << PUBLISHER << publisher.get_username() << WITH_ID  
             << publisher.get_id() << "register new film.";
    return notif.str();
}

Notification FilmService::rate_notification(Client client, Film film)
{
    stringstream notif;
    notif << USER_ST << client.get_username() << WITH_ID << client.get_id() 
            << " rate on your film " << WITH_ID << film.get_id() << ".";
    return notif.str();
}

Notification FilmService::comment_notification(Client client, Film film)
{
    stringstream notif;
    notif << USER_ST << client.get_username() << WITH_ID << client.get_id() 
            << " comment on your film " << WITH_ID << film.get_id() << ".";
    return notif.str();
}

Notification FilmService::buy_notification(Client client, Film film)
{
    stringstream notif;
    notif << USER_ST << client.get_username() << WITH_ID << client.get_id() 
            << " buy your film " << WITH_ID << film.get_id() << ".";
    return notif.str();
}


Notification FilmService::reply_notification(Publisher publisher)
{
    stringstream notif;
    notif << PUBLISHER_ST << publisher.get_username() << WITH_ID << publisher.get_id()
            << "reply to you comment.";

    return notif.str();
}
#include "FollowerController.h"

#include <sstream>

#include "Utils.h"
#include "Exceptions.h"
#include "Response.h"
#include "Client.h"

using namespace std;

Response FollowerController::post(Request* request)
{
    try 
    {
        current_request = request;
        int id = Utils::string_integer_value(request->get_request_param(USER_ID));

        user_service.follow(id);
    }
    catch(NotFound& er)
    {
        throw BadRequest("no id parameter");
    }

}


Response FollowerController::get(Request* request)
{

    current_request = request;
    return get_follower_response(user_service.get_followers());
    
}


Response FollowerController::get_follower_response (vector <const Client*> clients)
{
    stringstream res;
    res << "#. User Id | User Username | User Email" << endl;
    for (int i = 0; i < clients.size(); i++)
    {
        res << i + 1 << ". " << clients[i]->get_id() << " | "
                 << clients[i]->get_username() << " | " << clients[i]->get_email() << endl;
    }

    return Response(SUCCESSFUL,  res.str());
}#include "LoginController.h"

#include "Response.h"
#include "Request.h"
#include "Utils.h"
#include "Exceptions.h"
#include "UserService.h"
#include "UserService.h"
#include "md5.h"


Response LoginController::post(Request* req)
{
    current_request = req;
    try
    {
        post_required_params();
        UserService().login(req->get_request_param(USERNAME),
                md5(req->get_request_param(PASSWORD)));
    }
    catch(Exception* er)
    {
        return Response(ERROR, er->error());
    }
}

void LoginController::post_required_params()
{
    try
    {
        current_request->get_request_param(USERNAME);
        current_request->get_request_param(PASSWORD);

    }
    catch(NotFound& er)
    {
        throw BadRequest("a required parameter has not found");
    }
}#include <iostream>


#include "RequestReciever.h"
#include "ControllerManager.h"
#include "Request.h"
#include "Response.h"
#include "Exceptions.h"

#include "DataBase.h"

using namespace std;

int main()
{
    while (true)
    {
        try
        {
            Request my_request = RequestReciever().recieve_request();
            my_request.print_request();
            ControllerManager controller_manager;
            cout << "main line 19" << endl;
            controller_manager.run_controller(&my_request);
            cout << "main line 21" << endl;    
            cout << controller_manager.get_response() << endl;
        }
        catch(Exception& er)
        {
            #ifdef DEBUG
                cout<< er.error() << endl;            
            #endif
            
            #ifndef DEBUG 
                cout << er.what() << endl;
            #endif

        }
    }

    return 0;
}   /* MD5
 converted to C++ class by Frank Thilo (thilo@unix-ag.org)
 for bzflag (http://www.bzflag.org)
 
   based on:
 
   md5.h and md5.c
   reference implemantion of RFC 1321
 
   Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
 
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
 
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
 
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
 
These notices must be retained in any copies of any part of this
documentation and/or software.
 
*/
 
/* interface header */
#include "md5.h"
 
/* system implementation headers */
#include <cstdio>
 
 
// Constants for MD5Transform routine.
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21
 
///////////////////////////////////////////////
 
// F, G, H and I are basic MD5 functions.
inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) {
  return x&y | ~x&z;
}
 
inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) {
  return x&z | y&~z;
}
 
inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) {
  return x^y^z;
}
 
inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) {
  return y ^ (x | ~z);
}
 
// rotate_left rotates x left n bits.
inline MD5::uint4 MD5::rotate_left(uint4 x, int n) {
  return (x << n) | (x >> (32-n));
}
 
// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
// Rotation is separate from addition to prevent recomputation.
inline void MD5::FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {
  a = rotate_left(a+ F(b,c,d) + x + ac, s) + b;
}
 
inline void MD5::GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {
  a = rotate_left(a + G(b,c,d) + x + ac, s) + b;
}
 
inline void MD5::HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {
  a = rotate_left(a + H(b,c,d) + x + ac, s) + b;
}
 
inline void MD5::II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {
  a = rotate_left(a + I(b,c,d) + x + ac, s) + b;
}
 
//////////////////////////////////////////////
 
// default ctor, just initailize
MD5::MD5()
{
  init();
}
 
//////////////////////////////////////////////
 
// nifty shortcut ctor, compute MD5 for string and finalize it right away
MD5::MD5(const std::string &text)
{
  init();
  update(text.c_str(), text.length());
  finalize();
}
 
//////////////////////////////
 
void MD5::init()
{
  finalized=false;
 
  count[0] = 0;
  count[1] = 0;
 
  // load magic initialization constants.
  state[0] = 0x67452301;
  state[1] = 0xefcdab89;
  state[2] = 0x98badcfe;
  state[3] = 0x10325476;
}
 
//////////////////////////////
 
// decodes input (unsigned char) into output (uint4). Assumes len is a multiple of 4.
void MD5::decode(uint4 output[], const uint1 input[], size_type len)
{
  for (unsigned int i = 0, j = 0; j < len; i++, j += 4)
    output[i] = ((uint4)input[j]) | (((uint4)input[j+1]) << 8) |
      (((uint4)input[j+2]) << 16) | (((uint4)input[j+3]) << 24);
}
 
//////////////////////////////
 
// encodes input (uint4) into output (unsigned char). Assumes len is
// a multiple of 4.
void MD5::encode(uint1 output[], const uint4 input[], size_type len)
{
  for (size_type i = 0, j = 0; j < len; i++, j += 4) {
    output[j] = input[i] & 0xff;
    output[j+1] = (input[i] >> 8) & 0xff;
    output[j+2] = (input[i] >> 16) & 0xff;
    output[j+3] = (input[i] >> 24) & 0xff;
  }
}
 
//////////////////////////////
 
// apply MD5 algo on a block
void MD5::transform(const uint1 block[blocksize])
{
  uint4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
  decode (x, block, blocksize);
 
  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
  FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
  FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
  FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
  FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
  FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
  FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */
 
  /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
  GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
  GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
  GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */
 
  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
  HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */
 
  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
  II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
  II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
  II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
  II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
  II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
  II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
  II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */
 
  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
 
  // Zeroize sensitive information.
  memset(x, 0, sizeof x);
}
 
//////////////////////////////
 
// MD5 block update operation. Continues an MD5 message-digest
// operation, processing another message block
void MD5::update(const unsigned char input[], size_type length)
{
  // compute number of bytes mod 64
  size_type index = count[0] / 8 % blocksize;
 
  // Update number of bits
  if ((count[0] += (length << 3)) < (length << 3))
    count[1]++;
  count[1] += (length >> 29);
 
  // number of bytes we need to fill in buffer
  size_type firstpart = 64 - index;
 
  size_type i;
 
  // transform as many times as possible.
  if (length >= firstpart)
  {
    // fill buffer first, transform
    memcpy(&buffer[index], input, firstpart);
    transform(buffer);
 
    // transform chunks of blocksize (64 bytes)
    for (i = firstpart; i + blocksize <= length; i += blocksize)
      transform(&input[i]);
 
    index = 0;
  }
  else
    i = 0;
 
  // buffer remaining input
  memcpy(&buffer[index], &input[i], length-i);
}
 
//////////////////////////////
 
// for convenience provide a verson with signed char
void MD5::update(const char input[], size_type length)
{
  update((const unsigned char*)input, length);
}
 
//////////////////////////////
 
// MD5 finalization. Ends an MD5 message-digest operation, writing the
// the message digest and zeroizing the context.
MD5& MD5::finalize()
{
  static unsigned char padding[64] = {
    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  };
 
  if (!finalized) {
    // Save number of bits
    unsigned char bits[8];
    encode(bits, count, 8);
 
    // pad out to 56 mod 64.
    size_type index = count[0] / 8 % 64;
    size_type padLen = (index < 56) ? (56 - index) : (120 - index);
    update(padding, padLen);
 
    // Append length (before padding)
    update(bits, 8);
 
    // Store state in digest
    encode(digest, state, 16);
 
    // Zeroize sensitive information.
    memset(buffer, 0, sizeof buffer);
    memset(count, 0, sizeof count);
 
    finalized=true;
  }
 
  return *this;
}
 
//////////////////////////////
 
// return hex representation of digest as string
std::string MD5::hexdigest() const
{
  if (!finalized)
    return "";
 
  char buf[33];
  for (int i=0; i<16; i++)
    sprintf(buf+i*2, "%02x", digest[i]);
  buf[32]=0;
 
  return std::string(buf);
}
 
//////////////////////////////
 
std::ostream& operator<<(std::ostream& out, MD5 md5)
{
  return out << md5.hexdigest();
}
 
//////////////////////////////
 
std::string md5(const std::string str)
{
    MD5 md5 = MD5(str);
 
    return md5.hexdigest();
}#include "MoneyController.h"

#include "UserService.h"
#include "UserSessionManagement.h"
#include "Client.h"
#include "Utils.h"
#include "Exceptions.h"
#include "UTflix.h"

#define AMOUNT "amount"

Response MoneyController::post(Request* request)
{
    try
    {
        if(request->number_of_params() > 0)
        {
            current_request = request;
            Client* client = UserSessionManagement::get_instance()->get_logged_client();
            client->increase_credit(Utils::string_integer_value(request->get_request_param(AMOUNT)));
        }
        else
        {
            Publisher* publisher = UserSessionManagement::get_instance()->get_logged_publisher();
            UTflix::get_instance()->pay_publisher_debt(publisher);
        }

        return Response(SUCCESSFUL, OK);
    }
    catch(Exception& er)
    {
        return Response(ERROR, er.error());
    }

}#include "Notification.h"


Notification::Notification(std::string _content)
    :content(_content), read(false)
{}

bool Notification::is_read()
{
    return read;
}
#include "NotificationsController.h"

#include <sstream>

#include "Request.h"
#include "UserService.h"

using namespace std;

Response NotificationsController::get(Request* request)
{
    current_request = request;
    UserService user_service;
    return make_notification_response(user_service.get_notifications());
    
}

Response NotificationsController::make_notification_response(vector <string> notifs, int limit)
{
    if (limit = NO_LIMIT || limit > notifs.size())
        limit = notifs.size();
    stringstream res;
    int size = notifs.size();
    for (int i = size - 1; i >= size - limit; i--)
    {
        res << size - i << ". " << notifs[i] << endl;
    }
    return Response(SUCCESSFUL, res.str());
}#include "NotificationsReadController.h"


#include "Utils.h"
#include "Request.h"
#include "Exceptions.h"
#include "UserService.h"

#define LIMIT "limit"

Response NotificationsReadController ::get(Request* request)
{
    current_request = request;
    UserService user_service;
    try
    {
        limit = Utils::string_integer_value(current_request->get_request_param(LIMIT));
    }
    catch(NotFound er)
    {
        throw BadRequest("limit is not a number");
    }

    return make_notification_response(user_service.get_notifications(true));
}#include "PublishedController.h"

#include "Utils.h"
#include "FilmFilterService.h"
#include "FilmService.h"

Response PublishedController::get(Request* request)
{
    current_request = request;
    check_params();
    FilmFilterService film_filter(film_service.get_published());
    film_filter.filter(name , max_year, min_year, price, rate, director);
    film_filter.filter_not_available();
    films = film_filter.get_filtered();
    return make_get_film_respnse();
}

void PublishedController::check_params()
{
    re_initialize_params();
    FilmFilterController::check_params();
    // rate = Utils:: check rate
}
#include "Publisher.h"

#include "Film.h"
#include "Exceptions.h"
#include "DataBase.h"

using namespace std;

Publisher::Publisher(string email, string username, string password, int age)
    :Client(email, username, password, age)
{
    debt = 0;
}


void Publisher::add_film(Film* new_film)
{   
    published.insert(pair<int, Film*> (new_film->get_id(), new_film));
}

void Publisher:: delete_film(int film_id)
{
    if (published.find(film_id) == published.end())
        throw new PermissionDenied("film id doesn't belong to user");
    else
        published.erase(film_id);
}

bool Publisher::film_is_published_by_user(int film_id) const
{
    if (published.find(film_id) == published.end())
        return false;
    else
        return true;
}

void Publisher::add_follower(int id)
{
    followers.push_back(id);
}


std::vector <int> Publisher::get_followers() const
{
    return followers;
}


void Publisher:: reply_comment(int film_id, int comment_id)
{
    Film* film = DataBase::get_instance()->search_film(film_id);
    if (film_is_published_by_user(film_id));
        // if comment do exist or something
}

void Publisher::sell_film(int publisher_part)
{
    debt += publisher_part;
}

int Publisher::get_debt()
{
    return debt;
}

void Publisher::pay_debt()
{
    credit += debt;
    debt = 0;
}

vector <Film> Publisher::get_published()
{
    vector <Film> res;
    for (map <int, Film*>::iterator it = published.begin(); it != published.end(); it++)
    {
        res.push_back(*(it->second));
    }

    return res;
}

#include "PurchasedController.h"

#include "UserSessionManagement.h"

Response PurchasedController::get(Request* request)
{
    current_request = request;
    check_params();
    FilmFilterService film_filter(film_service.get_purchased());
    film_filter.filter(name , max_year, min_year, price, rate, director);
    films = film_filter.get_filtered();
    return make_get_film_respnse();
}#include "RateController.h"

#include "Utils.h"
#include "FilmService.h"
#include "Exceptions.h"

Response RateController::post(Request* request)
{
    current_request = request;
    FilmService film_service;
    film_service.rate(film_id, score);

    return Response(SUCCESSFUL, OK);
}

void RateController::check_post_params()
{
    try
    {
        film_id = Utils::string_integer_value(current_request->get_request_param(FILM_ID));
        score = Utils::string_integer_value(current_request->get_request_param(SCORE));
    }
    catch(Exception& er)
    {
        throw BadRequest("a required param doesn't exist");
    }
}#include "RepliesController.h"

#include "Utils.h"
#include "FilmService.h"
#include "Exceptions.h"


Response RepliesController::post(Request* request)
{
    current_request = request;   
    check_post_params();
    FilmService film_service;
    film_service.reply(film_id, comment_id, content);

    return Response(SUCCESSFUL, OK);
}

void RepliesController::check_post_params()
{
    try
    {
        film_id = Utils::string_integer_value(current_request->get_request_param(FILM_ID));
        comment_id = Utils::string_integer_value(current_request->get_request_param(COMMENT_ID));
        content = current_request->get_request_param(CONTENT);
    }
    catch(NotFound& er)
    {
        throw BadRequest("a required params do not exist");
    }
    

}#include <iostream>

#include "Request.h"

#include "Exceptions.h"


using namespace std;



Request::Request(vector <string> raw_request)
{
    map <string, int> methods = {{"GET",GET}, {"PUT", PUT}, {"POST",POST}, {"DELETE",DELETE}};
    string _operator = "?";
    const int COMPLEX_REQ_SIZE = 5;

    method = methods[raw_request[0]];
    url = raw_request[1];


    if (raw_request.size() >= COMPLEX_REQ_SIZE)
    {
        // cout << "number of tokens : " << raw_request.size() << endl;
        if ((raw_request.size() - 3 )% 2 == 1)
            throw BadRequest("key and values are not pair");
        for (int i = COMPLEX_REQ_SIZE - 1; i < raw_request.size(); i+=2)
        {
            parameters.insert(pair<string, string>(raw_request[i - 1], raw_request[i]));
        }
    }

}

void Request::print_request()
{
    cout << "method is  " << method << "  urls is:" << url << endl;
    for (map <string, string>::iterator it = parameters.begin(); it != parameters.end(); it++)
    cout << it->first << "   " << it->second << endl;
}

string Request::get_request_param(string key)
{
    string NOT_FOUND = "not found";
    if (parameters.find(key) != parameters.end())
        return parameters[key];
    else
        throw  NotFound("param doesn't exist");
}

int Request::get_method()
{
    return method;
}

std::string Request::get_url()
{
    return url;
}

int Request::number_of_params()
{
    return parameters.size();
}#include <iostream>

#include "Request.h"

#include "RequestReciever.h"

#include "Exceptions.h"

#include "Utils.h"





using namespace std;

Request RequestReciever::recieve_request()
{
    getline(cin, request_line);

    vector <string> tokens = parse_request();

    control_format(tokens);
    
    return Request(tokens);
    
}


//these two must be in utils




vector <string> RequestReciever::parse_request()
{
    string delimiters = "   ";
    vector <string> tokens = Utils::split_line(request_line, delimiters);
    int operator_index = Utils::find("?", tokens);

    int to;
    if (operator_index!= NOT_FOUND)
        to = operator_index - 1;
    else
        to = tokens.size() - 1;
    tokens = Utils::merge_tokens(1, to, tokens);


    return tokens;
}








void RequestReciever::control_format(vector <string> tokens)
{

    vector <string> standard_methods = {GET_, PUT_, POST_, DELETE_};
    vector <string> standard_urls = {SIGN_UP, LOGIN , FILMS/*, PUBLISHED*/, REPLIES, 
            COMMENTS, FOLLOWERS, MONEY, BUY/*, RATE, PURCHASED*/, NOTIFICATION, NOTIFICATION_READ};


    if (!valid_token(tokens[0], standard_methods))
        throw  BadRequest("method is not standard");

    
    if (!valid_token(tokens[1], standard_urls))
        throw  NotFound("url is not standard");

    
}


bool RequestReciever::valid_token(string token, vector <string> valid_tokens)
{
    for (int i = 0; i < valid_tokens.size(); i++)
    {
        if (token == valid_tokens[i])
            return true;
    }
    return false;
}#include "Response.h"

using namespace std;

Response::Response(int _type, string _content)
    :type(_type), content(_content)
{}

Response::Response()
    :type(EMPTY)
{}



ostream& operator<<(ostream& out, const Response& responese)
{
    out << responese.content;
    return out;
}#include "SignupController.h"

#include <string>

#include "DataBase.h"
#include "User.h"
#include "Client.h"
#include "Publisher.h"
#include "Request.h"
#include "Response.h"
#include "UserService.h"
#include "Utils.h"
#include "Exceptions.h"
#include "md5.h"

#define TRUE "true"
#define FALSE "false"

using namespace std;

Response SignupController::post(Request* req)
{
    current_request = req;
    publisher_flag = false;
    
    try
    {
        User* new_user;
        post_required_params();
        post_required_params();
        publisher_flag = is_publisher();
        UserService().signup(email, username, password, age, publisher_flag);
        return Response(SUCCESSFUL, OK);
    }
    catch (Exception& er)
    {
        return Response(ERROR, er.error());
    }
}

void SignupController::post_required_params()
{
    try
    {
        username = current_request->get_request_param(USERNAME);
        password = md5(current_request->get_request_param(PASSWORD));

        email = current_request->get_request_param(EMAIL);
        if (! Utils::is_valid_email(email))
            throw BadRequest("email is not valid");

        if (!Utils::is_valid_number(current_request->get_request_param(AGE))
                && stoi(current_request->get_request_param(AGE)) <= 0)
            throw BadRequest("age is not valid");
        else 
            age = stoi (current_request->get_request_param(AGE));
    }
    catch(NotFound& er)
    {
        throw BadRequest("required params are not complete");
    }
}




bool SignupController::is_publisher()
{
    const string NOT_ASSIGNED = "not assigned";
    string publisher_flag = NOT_ASSIGNED;
    try
    {
        publisher_flag = current_request->get_request_param(PUBLISHER_PARAM);
    }
    catch(Exception& er)
    {
        return false;
    }
    if (publisher_flag != TRUE && publisher_flag != FALSE && publisher_flag != NOT_ASSIGNED)
            throw BadRequest("value of publisher flag is not valid");

    return publisher_flag == TRUE? true : false;
}

#include "User.h"

using namespace std;


User::User(string _username, string _password)
    :username(_username), password(_password)
{}

bool User::valid_login(string _username, string _password)
{
    return (username == _username && password == _password);
}

int User::get_id() const
{
    return id;
}

std::string User::get_username() const
{
    return username;
}

int User::get_type() const
{
    return ADMIN;
}
#include "UserService.h"

#include <sstream>

#include "Response.h"
#include "Request.h"
#include "DataBase.h"
#include "Client.h"
#include "Publisher.h"
#include "md5.h"
#include "Exceptions.h"
#include "UserSessionManagement.h"

using namespace std;

UserService::UserService()
{
    database = DataBase::get_instance();
    user_manager = UserSessionManagement::get_instance();
}

void UserService::signup(std::string email, std::string username, std::string password, int age, bool publisher)
{
    Client* new_client;
    if (publisher)
        new_client = new Publisher(email,username, password, age);
    else
        new_client = new Client(email,username, password, age);

    database->add_client(new_client);
    login(username, password);
}

void UserService::login(string username, string password)
{
    if (database->search_client(username)->valid_login(username, password))
        user_manager->set_logged_user(database->search_client(username));
    else 
        throw new BadRequest("wrong password");
}

void  UserService::follow(int following_id)
{
    Client* logged_client = user_manager->get_logged_client();

    Publisher* publisher = dynamic_cast <Publisher*> (database->search_client(following_id));
    if (publisher != nullptr)
    {
        logged_client->follow(publisher);
        publisher->add_follower(logged_client->get_id());
        publisher->send_notif(follow_notification(*logged_client));
    }
    else 
        throw BadRequest("following id doesnt belong to a publisher");
}


vector <const Client*> UserService::get_followers()
{
    Publisher* publisher = user_manager->get_logged_publisher();

    vector <int> follower_ids;
    follower_ids = publisher->get_followers();

    vector <const Client*> followers;
    for (int i = 0; i < follower_ids.size(); i++)
        followers.push_back(database->search_client(follower_ids[i]));
    
    return followers;
}

vector <Notification> UserService::get_notifications(bool read)
{
    Publisher* publisehr = user_manager->get_logged_publisher();
    if (read)
        return publisehr->get_read_notification();

    return publisehr->get_notification();
}

Notification UserService::follow_notification(Client client)
{
    stringstream notif;
    notif << "User " << client.get_username() << "with id" << client.get_id() << "follow you.";
    return notif.str();
}
#include "UserSessionManagement.h"

#include "Exceptions.h"
#include "User.h"
#include "Publisher.h"
#include "Client.h"

UserSessionManagement* UserSessionManagement::instance = nullptr;

UserSessionManagement* UserSessionManagement::get_instance()
{
    if (instance == nullptr)
        instance = new UserSessionManagement();

    return  instance;
}

void UserSessionManagement::set_logged_user(User* _logged_user)
{
    // if (logged_user != nullptr)
    //     throw "some exception in case log out do exist";

    logged_user = _logged_user;
}

User* UserSessionManagement::get_logged_user()
{
    return logged_user;
}

Publisher* UserSessionManagement::get_logged_publisher()
{
    Publisher* publisher = dynamic_cast <Publisher*> (logged_user);
    if (publisher == NULL)
        throw PermissionDenied("this is not publisher type");
}

Client* UserSessionManagement::get_logged_client()
{
    Client* client = dynamic_cast <Client*> (logged_user);
    if (client == NULL)
        throw PermissionDenied("this is not client type");
}

bool UserSessionManagement::is_publisher()
{
    if (logged_user->get_type())
        return true;
    else 
        return false;
}

#include "UTflix.h"


UTflix* UTflix::instance = NULL;

UTflix* UTflix::get_instance()
{
    if (instance == NULL)
        instance = new UTflix();
    return instance;
}

void UTflix::pay_publisher_debt(Publisher* publisher)
{
    credit -= publisher->get_debt();
    publisher->pay_debt();
}

void UTflix::add_credit(int amount)
{
    credit += amount;
}
#include "Utils.h"

#include <iostream>
#include <regex>

#include "Exceptions.h"


using namespace std;

 bool Utils::is_in_string(char character, string checkString)
{
    for (int i = 0; i < checkString.length(); i++)
        if (character == checkString[i])
            return true;
    return false;
}

int Utils::find(string word, vector <string> line)
{
    for (int i = 0; i < line.size(); i++)
    {
        if (line[i] == word)
            return i;
    }
    return NOT_FOUND;
}


 vector <string> Utils::split_line(string line, string delimiters)
{
    // string delimiters = "   ";
    vector <string>  tokens;
    int start = 0; int length = 0;
    for (int i = 0; i < line.length(); i++)
    {
        if (is_in_string(line[i], delimiters))
        {
            if (length > 0)
                tokens.push_back(line.substr(start, length));


            start = i+1;
            length = 0;
        } 
        else
            length++;
    }
    tokens.push_back(line.substr(start, length));


    return tokens;  
}

vector <string> Utils::merge_tokens(int from, int to, vector <string> words)
{
    string merged = words[from];
    for (int i = from + 1; i <= to; i++)
    {
        merged += "/";
        merged += words[i];
        // cout << merged << endl;
    }

    words[from] = merged;
    for (int i = from + 1; i <= to; i++)
    {
        words.erase(words.begin() + i);
    }

    // for (int i = 0; i< words.size(); i++)
    //     cout << words[i] << endl;

    return words;
}

bool Utils::is_valid_email(string email)
{
    auto pattern = R"(^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$)";
    auto rx = std::regex{pattern, std::regex_constants::icase};
    return std::regex_match(email, rx);
}

bool Utils::is_valid_number(string number)
{
    if (number.empty())
        return false;
    for (int i = 0; i < number.size(); i++)
        if (!isdigit(number[i]))
            return false;
    return true;
}


int Utils::string_integer_value(string number)
{
    if (is_valid_number(number))
        return stoi(number);
    else
        throw BadRequest("value is not a number");
}
ifdef DEBUG
	CC = g++ -g -DDEBUG -std=c++11
else
	CC = g++ -g -std=c++11
endif

OBJECTS = \
		main.o \
		Utils.o \
		md5.o \
		Exceptions.o \
		RequestReciever.o \
		Request.o \
		Response.o \
		DataBase.o \
		UserSessionManagement.o \
		Controller.o \
		ControllerManager.o \
		SignupController.o \
		LoginController.o \
		FilmController.o \
		FollowerController.o \
		MoneyController.o \
		BuyController.o \
		RateController.o \
		RepliesController.o \
		CommentsController.o \
		PurchasedController.o \
		PublishedController.o \
		FilmFilterController.o\
		NotificationsController.o \
		NotificationsReadController.o \
		UserService.o \
		FilmService.o \
		FilmFilterService.o \
		User.o \
		Client.o \
		Publisher.o \
		Film.o \
		Comment.o \
		UTflix.o \

mainSensitivityList = \
		main.cpp \
		RequestReciever.h \
		Request.h \
		Response.h \
		ControllerManager.h \
		Controller.h \

UtilsSensitivityList = \
		Utils.cpp \
		Utils.h \

md5SensivityList = \
		md5.cpp \
		md5.h \

ExceptionsSensivityList = \
		Exceptions.cpp \
		Exceptions.h \

RequestRecieverSensitivityList = \
		RequestReciever.cpp \
		RequestReciever.h \
		Request.h \
		Exceptions.h \
		Utils.h \

RequestSensivityList = \
		Request.cpp \
		Request.h \
		Exceptions.h \

ResponseSensivityList = \
		Response.cpp \
		Response.h \

DataBaseSensivityList = \
		DataBase.cpp \
		DataBase.h \
		Exceptions.h \
		User.h \
		Client.h \
		Film.h \


UserSessionManagementSensivityList = \
		UserSessionManagement.cpp \
		UserSessionManagement.h \
		User.h \
		DataBase.h \

ControllerSensivityList = \
		Controller.cpp \
		Controller.h \
		Request.h \
		Response.h \
		Exceptions.h \


ControllerManagerSensivityList = \
		ControllerManager.cpp \
		ControllerManager.h \
		Controller.h \
		SignupController.h \
		LoginController.h \
		Request.h \
		Response.h \
		Exceptions.h \




SignupControllerSensivityList = \
		SignupController.cpp \
		SignupController.h \
		UserService.h \
		UserSessionManagement.h\
		Controller.h \
		User.h \
		Client.h \
		Publisher.h \
		Exceptions.h \
		md5.h \
		Utils.h \
		Response.h\
		Request.h \



LoginControllerSensivityList = \
		LoginController.cpp \
		LoginController.h \
		Controller.h \
		UserService.h \
		User.h \
		UserSessionManagement.h \
		Request.h \
		Response.h \

FilmControllerSensivityList = \
		FilmController.cpp \
		FilmController.h \
		Controller.h \
		FilmService.h \
		User.h \
		Client.h \
		Film.h \
		UserSessionManagement.h \
		Request.h \
		Response.h \
		DataBase.h \
		Comment.h \


FollowerControllerSensivityList = \
		FollowerController.cpp \
		FollowerController.h \
		Controller.h \
		UserService.h \
		Film.h \
		User.h \
		Publisher.h \
		Client.h \

MoneyControllerSensivityList = \
		MoneyController.cpp \
		MoneyController.h \
		Controller.h \
		UserSessionManagement.h \
		Client.h \
		Publisher.h \

BuyControllerSensivityList = \
		BuyController.cpp \
		BuyController.h \
		Controller.h \
		UserSessionManagement.h \
		Client.h \
		UTflix.h \
		Publisher.h \


RateControllerSensivityList = \
		RateController.cpp \
		RateController.h \
		Controller.h \
		FilmService.h \
		Utils.h \
		Exceptions.h \



RepliesControllerSensivityList = \
		RepliesController.cpp \
		RepliesController.h \
		Controller.h \
		FilmService.h \
		Utils.h \
		Exceptions.h \


CommentsControllerSensivityList = \
		CommentsController.cpp \
		CommentsController.h \
		Controller.h \
		FilmService.h \
		Utils.h \
		Exceptions.h \

PurchasedControllerSensivityList = \
		PurchasedController.cpp \
		FilmFilterController.h \
		FilmFilterService.h \

PublishedControllerSensivityList = \
		FilmFilterController.h \
		FilmFilterService.h \

FilmFilterControllerSensivityList = \
		FilmFilterController.h \
		FilmFilterService.h \




NotificationsControllerSensivityList = \
		NotificationsController.cpp \
		NotificationsController.h \
		Controller.h \
		UserService.h \
		Utils.h \
		Exceptions.h \


NotificationsReadControllerSensivityList = \
		NotificationsReadController.cpp \
		NotificationsReadController.h \
		Controller.h \
		UserService.h \
		Utils.h \
		Exceptions.h \


UserServiceSensivityList = \
		UserService.cpp \
		UserService.h \
		User.h \
		Client.h \
		Publisher.h \
		md5.h \
		Exceptions.h \
		UserSessionManagement.h \
		DataBase.h \

FilmServiceSensivityList = \
		FilmService.cpp \
		FilmService.h \
		DataBase.h \
		Exceptions.h \
		UserSessionManagement.h \
		Client.h \
		Publisher.h \
		Comment.h \


UserSensivityList = \
		User.cpp \
		User.h \

FilmFilterServiceSensivityList = \
		FilmFilterService.cpp \
		FilmFilterService.h \
		FilmService.h \
		Film.h \


ClientSensivityList = \
		Client.cpp \
		Client.h \
		User.h \
		Exceptions.h \
		Publisher.h \
		Film.h \


PublisherSensivityList = \
		Publisher.cpp \
		Publisher.h \
		Client.h \
		User.h \
		Film.h \
		Exceptions.h \


FilmSensivityList = \
		Film.cpp \
		Film.h \
		Exceptions.h \
		Utils.h \

CommentSensivitiyList = \
		Comment.cpp \
		Comment.h \

UTflixSensivityList = \
		UTflix.cpp \
		UTflix.h \
		Publisher.h \
		

all: UTflix.out 



main.o: $(mainSensitivityList)
	$(CC) -c main.cpp


Utils.o: $(UtilsSensitivityList)
	$(CC) -c  Utils.cpp

md5.o: $(md5SensivityList)
	$(CC) -c  md5.cpp

Exceptions.o: $(ExceptionsSensivityList)
	$(CC) -c  Exceptions.cpp

RequestReciever.o: $(RequestRecieverSensitivityList)
	$(CC) -c  RequestReciever.cpp

Request.o: $(RequestSensivityList)
	$(CC) -c  Request.cpp

Response.o: $(ResponseSensivityList)
	$(CC) -c  Response.cpp

DataBase.o: $(DataBaseSensivityList)
	$(CC) -c  DataBase.cpp

UserSessionManagement.o: $(UserSessionManagementSensivityList)
	$(CC) -c  UserSessionManagement.cpp

Controller.o: $(ControllerSensivityList)
	$(CC) -c  Controller.cpp

ControllerManager.o: $(ControllerManagerSensivityList)
	$(CC) -c  ControllerManager.cpp

SignupController.o: $(SignupControllerSensivityList)
	$(CC) -c  SignupController.cpp

LoginController.o: $(LoginControllerSensivityList)
	$(CC) -c  LoginController.cpp

FilmController.o: $(FilmControllerSensivityList)
	$(CC) -c FilmController.cpp

FollowerController.o: $(FollowerController)
	$(CC) -c FollowerController.cpp

MoneyController.o: $(MoneyControllerSensivityList)
	$(CC) -c MoneyController.cpp

BuyController.o: $(BuyControllerSensivityList)
	$(CC) -c BuyController.cpp

RateController.o: $(RateControllerSensivityList)
	$(CC) -c RateController.cpp

RepliesController.o: $(RepliesControllerSensivityList)
	$(CC) -c RepliesController.cpp

CommentsController.o: $(CommentsControllerSensivityList)
	$(CC) -c CommentsController.cpp

PublishedController.o: $(PublishedControllerSensivityList)
	$(CC) -c PublishedController.cpp

FilmFilterController.o: $(FilmFilterControllerSensivityList)
	$(CC) -c FilmFilterController.cpp

PurchasedController.o: $(PurchasedControllerSensivityList)
	$(CC) -c PurchasedController.cpp

NotificationsController.o: $(NotificationsSensivityList)
	$(CC) -c NotificationsController.cpp

NotificationsReadController.o: $(NotificationsReadControllerSensivityList)
	$(CC) -c NotificationsReadController.cpp


UserService.o: $(UserServiceSensivityList)
	$(CC) -c  UserService.cpp

FilmService.o: $(FilmServiceSensivityList)
	$(CC) -c FilmService.cpp

FilmFilterService.o: $(FilmFilterServiceSensivityList)
	$(CC) -c FilmFilterService.cpp

User.o: $(UserSensivityList)
	$(CC) -c  User.cpp

Client.o: $(ClientSensivityList)
	$(CC) -c  Client.cpp

Publisher.o: $(PublisherSensivityList)
	$(CC) -c  Publisher.cpp

Film.o: $(FilmSensivityList)
	$(CC) -c  Film.cpp

Comment.o: $(CommentSensivitiyList)
	$(CC) -c  Comment.cpp

UTflix.o: $(UTflixSensivityList)
	$(CC) -c UTflix.cpp

UTflix.out: $(OBJECTS)
	$(CC) -o UTflix.out $(OBJECTS)

.PHONY: clean

clean:
	rm *.o
	rm UTflix.out